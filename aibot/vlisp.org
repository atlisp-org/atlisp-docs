* vl-string->list
** (vl-string->list  string)
将字符串转换为字符代码表
* vl-princ-to-string
** (vl-princ-to-string  data)
返回 LISP 数据的字符串表示，就象它是由 princ 函数输出的一样
* vl-mkdir,创建目录
** (vl-mkdir directoryname)
创建目录
* vl-list-loaded-vlx
** (vl-list-loaded-vlx)
返回与当前文档相关联的所有独立名称空间 VLX 文件
* vl-filename-directory
** (vl-filename-directory filename)
去掉文件的名称和扩展名，返回文件的路径。
* vl-list*
** (vl-list*  object[object]...)
构造并返回表
* _vl-times
** (_vl-times)
下面是用法
(setq start (car (_vl-times)))
;测试代码
(/(-(car (_vl-times))start)1000.)
计时器函数，可用于计算程序运行效率
* vl-infp
** (vl-infp num)
(vl-infp 333)  返回nil
(vl-infp 1e2222) 返回T,判断一个数是否无穷大
* vl-bt
** (vl-bt)
错误跟踪
;(defun c:tt6 ( / *ERROR* )
;	(defun *ERROR* (ERROR )
;		(vl-bt)
;	)	
;	(+ 12 ""asd"")
;)
* vl-acad-defun
** (vl-acad-defun 'symbol)
将 Visual LISP 函数符号定义为外部子例程
* vl-acad-undefun
** (vl-acad-undefun 'symbol)
取消对 Visual LISP 函数符号的定义，使 ObjectARX 应用程序不能再使用它。
* vl-arx-import
** (vl-arx-import ['function , "application"])
将 ObjectARX/ADSRX 函数输入到独立名称空间 VLX
* vl-bb-ref
** (vl-bb-ref 'variable)
返回黑板名称空间中变量的值
* vl-bb-set
** (vl-bb-set 'symbol value)
设置黑板名称空间中的变量
* vl-catch-all-apply
** (vl-catch-all-apply 'function list)
将参数表传递给指定函数并截取错误
* vl-catch-all-error-message
** (vl-catch-all-error-message error-obj)
从错误对象返回字符串
* vl-catch-all-error-p
** (vl-catch-all-error-p arg)
确定参数是否是 vl-catch-all-apply 返回的错误对象
* vl-cmdf
** (vl-cmdf  [arguments] ...)
执行 AutoCAD 命令
* vl-consp
** (vl-consp list-variable)
确定表是否不为 nil
* vl-directory-files
** (vl-directory-files [directory pattern directories])
获取指定目录中的所有文件夹列表
* vl-doc-export
** (vl-doc-export 'function)
使函数在当前文档中可用
* vl-doc-import
** (vl-doc-import application [’function...])
将早先输出的函数输入到 VLX 名称空间
* vl-doc-ref
** (vl-doc-ref 'symbol)
从当前文档名称空间中获取变量的值
* vl-doc-set
** (vl-doc-set 'symbol value)
设置当前文档名称空间中变量的值
* vl-every
** (vl-every  predicate-function list [list]...)
检查论断结合每个元素后是否均为真
* vl-exit-with-error
** (vl-exit-with-error msg)
将控制从 VLX 错误处理器传递给调用它的名称空间的 *error* 函数
* vl-exit-with-value
** (vl-exit-with-value value)
将值返回到从其他名称空间调用 VLX 的函数
* vl-file-copy
** (vl-file-copy  source-file destination-file [append])
将一个文件的内容复制或附加到另一个文件
* vl-file-delete
** (vl-file-delete  filename)
删除文件
* vl-file-directory-p
** (vl-file-directory-p path)
判断文件夹是否存在
* vl-filename-base
** (vl-filename-base  filename)
去掉文件的路径和扩展名，返回文件的名称
* vl-filename-extension
** (vl-filename-extension  filename)
返回文件的扩展名，而去掉文件名中的其他部分
* vl-filename-mktemp
** (vl-filename-mktemp [pattern directory extension])
为临时文件计算唯一的文件名
* vl-file-rename
** (vl-file-rename  old-filename new-filename)
重命名文件
* vl-file-size
** (vl-file-size  filename)
确定文件的大小（字节）
* vl-file-systime
** (vl-file-systime filename)
返回指定文件的上一次修改时间
* vl-get-resource
** (vl-get-resource text-file)
返回 VLX 中保存的 .txt 文件中的文字
* vl-list-exported-functions
** (vl-list-exported-functions [appname])
列出输出的函数
* vl-list-length
** (vl-list-length  list-or-cons-object)
计算表的长度
* vl-list->string
** (vl-list->string char-codes-list)
将一系列与整数表相关联的字符组合成字符串 。
* vl-load-all
** (vl-load-all filename)
将文件加载到所有打开的 AutoCAD 文档中,以及在当前 AutoCAD 任务中后续打开的任何文档中
* vl-load-com
** (vl-load-com)
将 Visual LISP 扩展功能加载到 * false,false
* vl-load-reactors
** (vl-load-reactors)
加载反应器支持函数
* vl-member-if
** (vl-member-if  predicate-function list)
确定论断是否对每一个表成员都正确
* vl-member-if-not
** (vl-member-if-not predicate-function list)
确定论断是否对表成员中的一个为 nil
* vl-position
** (vl-position  symbol list)
返回指定表项目的索引
* vl-prin1-to-string
** (vl-prin1-to-string  data)
返回 LISP 数据的字符串表示，就象它是由 prin1 函数输出的一样
* vl-propagate
** (vl-propagate 'symbol)
将变量的值复制到所有打开的文档名称空间（并在当前 AutoCAD 任务中打开的所有后续图形中设置它的值）
* vl-registry-delete
** (vl-registry-delete reg-key [val-name])
从 Winows 注册表中删除指定的主键或值
* vl-registry-descendents
** (vl-registry-descendents reg-key [val-names])
返回指定注册表键的子键或值名称的列表
* vl-registry-read
** (vl-registry-read reg-key [val-name])
对于指定的主键/值对，返回 Winodws 注册表存储的数据
* vl-registry-write
** (vl-registry-write reg-key [val-name val-data])
在 Windows 注册表中创建主键
* vl-remove
** (vl-remove  element-to-remove list)
删除表中的元素
* vl-remove-if
** (vl-remove-if  predicate-function list)
返回由所提供表中的所有不满足测试函数的元素组成的表
* vl-remove-if-not
** (vl-remove-if-not  predicate-function list)
返回由所提供表中的所有能通过测试函数的元素组成的表
* vl-some
** (vl-some  predicate-functionlist [list]...)
检查论断是否对某个元素组合不为 nil
* vl-sort
** (vl-sort  list comparison-function)
根据给定的比较函数来对表中的元素排序
* vl-sort-i
** (vl-sort-i  list comparison-function)
根据给定的比较函数对表中的元素排序，并返回元素的索引号
* vl-string-elt
** (vl-string-elt string position)
返回字符串中指定位置字符的 ASCII 表示
* vl-string-left-trim
** (vl-string-left-trim char-set string)
返回从源字符串首端开始，挨个删除所提供的字符集中的字符(遇到不属于字符集中的则结束)后的字符串
* vl-string-mismatch
** (vl-string-mismatch str1 str2 [pos1 pos2 ignore-case-p])
返回两个字符串中从指定位置开始，最长的共同前缀的长度
* vl-string-position
** (vl-string-position char-code str [start-pos [from-end-p]])
在字符串中查找具有指定 ASCII 码的字符
* vl-string-right-trim
** (vl-string-right-trim char-set string)
返回从源字符串尾端开始，挨个删除所提供的字符集中的字符(遇到不属于字符集中的则结束)后的字符串
* vl-string-search
** (vl-string-search pattern string [start-pos])
在字符串中搜索指定子串
* vl-string-subst
** (vl-string-subst new-str pattern string [start-pos])
返回从头起或从指定位置起，替换一次子字符串后的字符串
* vl-string-translate
** (vl-string-translate source-set dest-set str)
在字符串中替换字符
* vl-string-trim
** (vl-string-trim char-set str)
返回从源字符串首端和尾端开始，分别挨个删除所提供的字符集中的字符(分别遇到不属于字符集中的则分别结束)后的字符串
* vl-symbol-name
** (vl-symbol-name  symbol)
返回包含某符号名的字符串
* vl-symbolp
** (vl-symbolp object)
确定指定对象是否为符号
* vl-symbol-value
** (vl-symbol-value symbol)
返回当前绑定到符号的值
* vl-unload-vlx
** (vl-unload-vlx appname)
卸载已经加载到自己的名称空间的 VLX 应用程序
* vl-vbaload
** (vl-vbaload filename)
加载 Visual Basic 工程
* vl-vbarun
** (vl-vbarun  macroname)
运行 Visual Basic 宏
* vl-vlx-loaded-p
** (vl-vlx-loaded-p appname)
确定某独立名称空间当前是否加载
